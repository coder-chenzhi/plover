package plover.sootex.du;

import java.util.*;

import plover.soot.Cache;
import plover.sootex.location.AccessPath;
import plover.sootex.location.Location;
import plover.sootex.ptsto.IPtsToQuery;
import plover.sootex.ptsto.PtsToHelper;
import plover.sootex.sideeffect.ISideEffectAnalysis;
import plover.soot.callgraph.Callees;
import plover.soot.hammock.CFGEntry;
import plover.soot.hammock.CFGExit;
import soot.*;
import soot.jimple.DefinitionStmt;
import soot.jimple.IdentityStmt;
import soot.jimple.InstanceInvokeExpr;
import soot.jimple.InvokeExpr;
import soot.jimple.NewArrayExpr;
import soot.jimple.NewExpr;
import soot.jimple.NewMultiArrayExpr;
import soot.jimple.ReturnStmt;
import soot.jimple.Stmt;
import soot.jimple.toolkits.callgraph.CallGraph;
import soot.toolkits.graph.*;

/**
 *  A reaching definition analysis implemented with bit vectors.
 */
public class RDAnalysis extends DUAnalysis{
	protected IPtsToQuery _pt2Query;
 
	public RDAnalysis(MethodOrMethodContext mc, DirectedGraph<Unit> graph, IPtsToQuery pt2Query,
					  ISideEffectAnalysis sideEffect){
		super(mc, graph, sideEffect);
		this._pt2Query = pt2Query;
	} 
	
	public void build(){
		super.build();
		_pt2Query = null;
	}
	
	/** ID name of the analysis  */
	protected String getAnalysisName(){
		return "RD";
	}
	
	/** DEF set at the method entry. */
	protected Collection<ReachingDU> getEntryDU(){
		Unit entry = CFGEntry.v();
		Collection<ReachingDU> entrySet = new ArrayList<ReachingDU>();
		 
		// parameters, including the globals
		Collection<Location> params = collectParams();
		for (Location loc : params) {
			AccessPath ap = AccessPath.getByRoot(loc);
			entrySet.add(new ReachingDU(entry, ap, loc));
		}

		return entrySet;
	} 
 
	/** collect the reaching definitions generated by a method call. 
	 *  NOTE: The definition on the return value has already been considered, 
	 *  	  this method just needs to collect the definition on global locations
	 *
	 */
	protected Collection<ReachingDU> collectInvokeDefs(Unit invokeStmt){
		if (_sideEffect == null) {
			return new ArrayList<>();
		}

//		if (invokeStmt.toString().equals("rc = virtualinvoke dt.<org.apache.zookeeper.server.DataTree: org.apache.zookeeper.server.DataTree$ProcessTxnResult processTxn(org.apache.zookeeper.txn.TxnHeader,org.apache.jute.Record)>(hdr, txn)")) {
//			System.out.println("Pause");
//		}
		Collection<ReachingDU> rdSet = new ArrayList<ReachingDU>(); 
	    CallGraph cg = Scene.v().getCallGraph();
	    
	    Callees callees  = new Callees(cg, invokeStmt);
	    
	    // XXX: We do not consider the effects of sub threads here
	    //      For multiple thread programs, we need other analysis to find the inter-thread dependencies
	    callees.all().removeAll(callees.threads());

	    List<SootMethod> tgtMethods = new ArrayList<>();

		// collect definitions to heap location
	    if(callees.all().size() >= 1) {
			tgtMethods.addAll(callees.all());
	    } else if (((Stmt)invokeStmt).containsInvokeExpr()){
			// workaround for imprecision of call graph
			tgtMethods.add(((Stmt)invokeStmt).getInvokeExpr().getMethod());
		}

		for(SootMethod tgt: tgtMethods){
			Collection<Location> mod = new HashSet<>();
			if (tgt.isConcrete()){
				Collection<AccessPath> modAp = _sideEffect.getModHeapLocs(tgt);
				if (modAp == null) {
					continue;
				}
				Collection<AccessPath> mappingModAp = _sideEffect.getMappingAccessPath((Stmt) invokeStmt, tgt, modAp);
				for (AccessPath ap : mappingModAp) {
					// TODO pay attention to the underlying implementation,
					//  it can be field sensitive point-to analysis or field insensitive point-to analysis
					mod = PtsToHelper.getAccessedLocations(_pt2Query, null, ap);
					ReachingDU rd = new ReachingDU(invokeStmt, ap, mod);
					rdSet.add(rd);
				}
			}
			else{
				rdSet.addAll(getNativeCallMod(invokeStmt, tgt));
			}

		}

	    LOGGER.trace("RdSet {} for InvokeStmt {}", rdSet, invokeStmt);
		return rdSet; 
	} 
	
	@SuppressWarnings("unchecked")
	private Collection<ReachingDU> getNativeCallMod(Unit u, SootMethod tgt){
		Collection<ReachingDU> rdSet = new ArrayList<ReachingDU>();

		InvokeExpr invoke = ((Stmt)u).getInvokeExpr();
		Value receiver = null;
		if(!invoke.getMethod().isStatic()){
			InstanceInvokeExpr iie = (InstanceInvokeExpr)invoke;
			receiver = iie.getBase();
		}
		Collection<AccessPath> def = NativeMethodDUHelper.v().getDef(tgt, receiver, invoke.getArgs());
		if(def.size() > 0){
			Collection<Location> locs = new HashSet<Location>();
			for(AccessPath d: def){
				// TODO pay attention to the underlying implementation,
				//  it can be field sensitive point-to analysis or field insensitive point-to analysis
				Collection<Location> defLocs = PtsToHelper.getAccessedLocations(_pt2Query, u, d);
				ReachingDU ru = new ReachingDU(u, d, defLocs);
				rdSet.add(ru);
			}
		}
		return rdSet;
	}

	/** Collect RD of each statement */
	protected Collection<ReachingDU> collectStmtDU(Unit u){
		if(u==CFGEntry.v()){	 
			return getEntryDU();
		}		
		if(u== CFGExit.v() || u instanceof IdentityStmt || !(u instanceof Stmt)){
			return Collections.emptyList();
		}  	
		
		Collection<ReachingDU> rdSet = new ArrayList<ReachingDU>();
		
		Stmt s = (Stmt)u;
		for(Object box: s.getDefBoxes()){
			Value v = ((ValueBox)box).getValue();
			AccessPath def = AccessPath.valueToAccessPath(_method, s, v);	
			ReachingDU rd;
			if (def.length() == 0) {		 
				rd = new ReachingDU(u, def, def.getRoot());
			} else {
				// TODO pay attention to the underlying implementation,
				//  it can be field sensitive point-to analysis or field insensitive point-to analysis
				Collection<Location> defLocs = PtsToHelper.getAccessedLocations(_pt2Query, u, def);
				rd = new ReachingDU(u, def, defLocs);
			}
			rdSet.add(rd);
		}
		
		// each new expression will generate a couple of assignments initializing the fields to their default value
        if(s instanceof DefinitionStmt){
        	DefinitionStmt ds = (DefinitionStmt)s;
        	Value leftOp = ds.getLeftOp();
        	Value rightOp = ds.getRightOp();

        	// TODO check if effects of new expressions have been calculated in side-effect analysis
        	if (rightOp instanceof NewExpr) {
            	AccessPath left = AccessPath.valueToAccessPath(_method, s, leftOp);
            	RefType type = (RefType)rightOp.getType();
            	SootClass cls = type.getSootClass();
            	Collection<SootField> fields = Cache.v().getAllInstanceFields(cls);
            	for(SootField f: fields){
            		AccessPath ap = left.appendFieldRef(f);
					// TODO pay attention to the underlying implementation,
					//  it can be field sensitive point-to analysis or field insensitive point-to analysis
            		Collection<Location> defLocs = PtsToHelper.getAccessedLocations(_pt2Query, u, ap);
            		ReachingDU rd = new ReachingDU(u,ap,defLocs);
         	        rdSet.add(rd);
            	}
            }
        	else if(rightOp instanceof NewArrayExpr || rightOp instanceof NewMultiArrayExpr){
        		AccessPath left = AccessPath.valueToAccessPath(_method, s, leftOp);
        		AccessPath ap = left.appendArrayRef();
				// TODO pay attention to the underlying implementation,
				//  it can be field sensitive point-to analysis or field insensitive point-to analysis
        		Collection<Location> defLocs = PtsToHelper.getAccessedLocations(_pt2Query, u, ap);
            	ReachingDU rd = new ReachingDU(u,ap,defLocs);
         	    rdSet.add(rd);
        	}
        } 
        else if(s instanceof ReturnStmt){
        	// treat return as a definition to a unique return value
        	Location ret = Location.methodToRet(_method);
        	AccessPath def = AccessPath.getByRoot(ret);	
			ReachingDU rd = new ReachingDU(u, def, ret);
			rdSet.add(rd);
        } 
        
	    //if there exits a method call
	    if(s.containsInvokeExpr()){	 
	    	Collection<ReachingDU> rds = collectInvokeDefs(u);
	        rdSet.addAll(rds);	   
	    }

	    LOGGER.trace("RdSet {} for unit {}", rdSet, u);
	 	return rdSet;	
	}
}
